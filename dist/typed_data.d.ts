import { OperatorMethods, double, bool, int } from "./utils";
import * as core from "./core";
export declare class ByteBuffer extends ArrayBuffer {
    static _withLength(len: number): ByteBuffer;
    static withLength: new (len: number) => ByteBuffer;
    static _fromBuffer(buffer: ArrayBuffer): ByteBuffer;
    static fromBuffer: new (buffer: ArrayBuffer) => ByteBuffer;
    readonly lengthInBytes: number;
    asUint8List(offsetInBytes?: number, length?: number): Uint8List;
    asInt8List(offsetInBytes?: number, length?: number): Int8List;
    asUint8ClampedList(offsetInBytes?: number, length?: number): Uint8ClampedList;
    asUint16List(offsetInBytes?: number, length?: number): Uint16List;
    asInt16List(offsetInBytes?: number, length?: number): Int16List;
    asUint32List(offsetInBytes?: number, length?: number): Uint32List;
    asInt32List(offsetInBytes?: number, length?: number): Int32List;
    asUint64List(offsetInBytes?: number, length?: number): Uint64List;
    asInt64List(offsetInBytes?: number, length?: number): Int64List;
    asInt32x4List(offsetInBytes?: number, length?: number): Int32x4List;
    asFloat32List(offsetInBytes?: number, length?: number): Float32List;
    asFloat64List(offsetInBytes?: number, length?: number): Float64List;
    asFloat32x4List(offsetInBytes?: number, length?: number): Float32x4List;
    asFloat64x2List(offsetInBytes?: number, length?: number): Float64x2List;
    asByteData(offsetInBytes?: number, length?: number): ByteData;
}
export declare class TypedData {
    readonly elementSizeInBytes: number;
    readonly offsetInBytes: number;
    readonly lengthInBytes: number;
    readonly buffer: ByteBuffer;
}
export declare class ByteData extends TypedData {
    constructor(length: number);
    static _ByteData(length: number): ByteData;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): ByteData;
    static view: new (buffer: ByteBuffer, offsetInBytes?: number, length?: number) => ByteData;
    getInt8(byteOffset: number): number;
    setInt8(byteOffset: number, value: number): void;
    getUint8(byteOffset: number): number;
    setUint8(byteOffset: number, value: number): void;
    getInt16(byteOffset: number, endian?: Endianness): number;
    setInt16(byteOffset: number, value: number, endian?: Endianness): void;
    getUint16(byteOffset: number, endian?: Endianness): number;
    setUint16(byteOffset: number, value: number, endian?: Endianness): void;
    getInt32(byteOffset: number, endian?: Endianness): number;
    setInt32(byteOffset: number, value: number, endian?: Endianness): void;
    getUint32(byteOffset: number, endian?: Endianness): number;
    setUint32(byteOffset: number, value: number, endian?: Endianness): void;
    getInt64(byteOffset: number, endian?: Endianness): number;
    setInt64(byteOffset: number, value: number, endian?: Endianness): void;
    getUint64(byteOffset: number, endian?: Endianness): number;
    setUint64(byteOffset: number, value: number, endian?: Endianness): void;
    getFloat32(byteOffset: number, endian?: Endianness): double;
    setFloat32(byteOffset: number, value: double, endian?: Endianness): void;
    getFloat64(byteOffset: number, endian?: Endianness): double;
    setFloat64(byteOffset: number, value: double, endian?: Endianness): void;
}
export declare class Uint16List extends TypedData implements core.DartList<number> {
    constructor(length: number);
    static _Uint16List(length: number): Uint16List;
    static _fromList(elements: core.DartList<number>): Uint16List;
    static fromList: new (elements: core.DartList<number>) => Uint16List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Uint16List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Uint16List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Int8List extends TypedData implements core.DartList<number> {
    constructor(length: number);
    static _Int8List(length: number): Int8List;
    static _fromList(elements: core.DartList<number>): Int8List;
    static fromList: new (elements: core.DartList<number>) => Int8List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Int8List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Int8List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Uint8List extends TypedData implements core.DartList<number> {
    constructor(length: number);
    static _Uint8List(length: number): Uint8List;
    static _fromList(elements: core.DartList<number>): Uint8List;
    static fromList: new (elements: core.DartList<number>) => Uint8List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Uint8List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Uint8List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Uint8ClampedList extends TypedData implements core.DartList<number> {
    constructor(length: number);
    static _Uint8ClampedList(length: number): Uint8ClampedList;
    static _fromList(elements: core.DartList<number>): Uint8ClampedList;
    static fromList: new (elements: core.DartList<number>) => Uint8ClampedList;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Uint8ClampedList;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Uint8ClampedList;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Int16List extends TypedData implements core.DartList<number> {
    constructor(length: number);
    static _Int16List(length: number): Int16List;
    static _fromList(elements: core.DartList<number>): Int16List;
    static fromList: new (elements: core.DartList<number>) => Int16List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Int16List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Int16List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Int32List extends TypedData implements core.DartList<number> {
    constructor(length: number);
    static _Int32List(length: number): Int32List;
    static _fromList(elements: core.DartList<number>): Int32List;
    static fromList: new (elements: core.DartList<number>) => Int32List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Int32List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Int32List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Uint32List extends TypedData implements core.DartList<number> {
    constructor(length: number);
    static _Uint32List(length: number): Uint32List;
    static _fromList(elements: core.DartList<number>): Uint32List;
    static fromList: new (elements: core.DartList<number>) => Uint32List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Uint32List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Uint32List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Int64List extends TypedData implements core.DartList<number> {
    constructor(length: number);
    static _Int64List(length: number): Int64List;
    static _fromList(elements: core.DartList<number>): Int64List;
    static fromList: new (elements: core.DartList<number>) => Int64List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Int64List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Int64List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Uint64List extends TypedData implements core.DartList<number> {
    constructor(length: number);
    static _Uint64List(length: number): Uint64List;
    static _fromList(elements: core.DartList<number>): Uint64List;
    static fromList: new (elements: core.DartList<number>) => Uint64List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Uint64List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Uint64List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Float32List extends TypedData implements core.DartList<double> {
    constructor(length: number);
    static _Float32List(length: number): Float32List;
    static _fromList(elements: core.DartList<double>): Float32List;
    static fromList: new (elements: core.DartList<double>) => Float32List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Float32List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Float32List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Float64List extends TypedData implements core.DartList<double> {
    constructor(length: number);
    static _Float64List(length: number): Float64List;
    static _fromList(elements: core.DartList<double>): Float64List;
    static fromList: new (elements: core.DartList<double>) => Float64List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Float64List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Float64List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
}
export declare class Float32x4List extends TypedData implements core.DartList<Float32x4> {
    constructor(length: number);
    static _Float32x4List(length: number): Float32x4List;
    static _fromList(elements: core.DartList<Float32x4>): Float32x4List;
    static fromList: new (elements: core.DartList<Float32x4>) => Float32x4List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Float32x4List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Float32x4List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): Float32x4;
    [OperatorMethods.INDEX_EQ](index: number, value: Float32x4): void;
    add(element: Float32x4): void;
    addAll(iterable: core.DartIterable<Float32x4>): void;
    any(test: (element: Float32x4) => bool): bool;
    asMap(): core.DartMap<int, Float32x4>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): Float32x4;
    expand<T>(f: (element: Float32x4) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: Float32x4): void;
    readonly first: Float32x4;
    firstWhere(test: (element: Float32x4) => bool, _?: {
        orElse?: () => Float32x4;
    }): Float32x4;
    fold<T>(initialValue: T, combine: (previousValue: T, element: Float32x4) => T): T;
    getRange(start: int, end: int): core.DartIterable<Float32x4>;
    insert(index: int, element: Float32x4): void;
    insertAll(index: int, iterable: core.DartIterable<Float32x4>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<Float32x4>;
    readonly last: Float32x4;
    lastWhere(test: (element: Float32x4) => bool, _?: {
        orElse?: () => Float32x4;
    }): Float32x4;
    map(...args: any[]): any;
    remove(element: Float32x4): bool;
    removeAt(index: int): Float32x4;
    removeLast(): Float32x4;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: Float32x4) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<Float32x4>): void;
    retainWhere(test: (element: Float32x4) => bool): void;
    readonly reversed: core.DartIterable<Float32x4>;
    setAll(index: int, iterable: core.DartIterable<Float32x4>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: Float32x4;
    singleWhere(test: (element: Float32x4) => bool): Float32x4;
    skip(count: int): core.DartIterable<Float32x4>;
    skipWhile(test: (element: Float32x4) => bool): core.DartIterable<Float32x4>;
    take(count: int): core.DartIterable<Float32x4>;
    takeWhile(test: (element: Float32x4) => bool): core.DartIterable<Float32x4>;
    toList(_?: {
        growable: bool;
    }): core.DartList<Float32x4>;
    toSet(): core.DartSet<Float32x4>;
    where(test: (element: Float32x4) => bool): core.DartIterable<Float32x4>;
    [Symbol.iterator](): Iterator<Float32x4>;
    every(f: (element: Float32x4) => boolean): boolean;
    forEach(f: (element: Float32x4) => any): void;
    indexOf(element: Float32x4, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: Float32x4, start?: int): int;
    reduce(combine: (value: Float32x4, element: Float32x4) => Float32x4): Float32x4;
    sort(compare?: (a: Float32x4, b: Float32x4) => int): void;
    sublist(start: int, end?: int): core.DartList<Float32x4>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<Float32x4>, skipCount?: int): void;
}
export declare class Int32x4List extends TypedData implements core.DartList<Int32x4> {
    constructor(length: number);
    static _Int32x4List(length: number): Int32x4List;
    static _fromList(elements: core.DartList<Int32x4>): Int32x4List;
    static fromList: new (elements: core.DartList<Int32x4>) => Int32x4List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Int32x4List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Int32x4List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): Int32x4;
    [OperatorMethods.INDEX_EQ](index: number, value: Int32x4): void;
    add(element: Int32x4): void;
    addAll(iterable: core.DartIterable<Int32x4>): void;
    any(test: (element: Int32x4) => bool): bool;
    asMap(): core.DartMap<int, Int32x4>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): Int32x4;
    expand<T>(f: (element: Int32x4) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: Int32x4): void;
    readonly first: Int32x4;
    firstWhere(test: (element: Int32x4) => bool, _?: {
        orElse?: () => Int32x4;
    }): Int32x4;
    fold<T>(initialValue: T, combine: (previousValue: T, element: Int32x4) => T): T;
    getRange(start: int, end: int): core.DartIterable<Int32x4>;
    insert(index: int, element: Int32x4): void;
    insertAll(index: int, iterable: core.DartIterable<Int32x4>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<Int32x4>;
    readonly last: Int32x4;
    lastWhere(test: (element: Int32x4) => bool, _?: {
        orElse?: () => Int32x4;
    }): Int32x4;
    map(...args: any[]): any;
    remove(element: Int32x4): bool;
    removeAt(index: int): Int32x4;
    removeLast(): Int32x4;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: Int32x4) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<Int32x4>): void;
    retainWhere(test: (element: Int32x4) => bool): void;
    readonly reversed: core.DartIterable<Int32x4>;
    setAll(index: int, iterable: core.DartIterable<Int32x4>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: Int32x4;
    singleWhere(test: (element: Int32x4) => bool): Int32x4;
    skip(count: int): core.DartIterable<Int32x4>;
    skipWhile(test: (element: Int32x4) => bool): core.DartIterable<Int32x4>;
    take(count: int): core.DartIterable<Int32x4>;
    takeWhile(test: (element: Int32x4) => bool): core.DartIterable<Int32x4>;
    toList(_?: {
        growable: bool;
    }): core.DartList<Int32x4>;
    toSet(): core.DartSet<Int32x4>;
    where(test: (element: Int32x4) => bool): core.DartIterable<Int32x4>;
    [Symbol.iterator](): Iterator<Int32x4>;
    every(f: (element: Int32x4) => boolean): boolean;
    forEach(f: (element: Int32x4) => any): void;
    indexOf(element: Int32x4, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: Int32x4, start?: int): int;
    reduce(combine: (value: Int32x4, element: Int32x4) => Int32x4): Int32x4;
    sort(compare?: (a: Int32x4, b: Int32x4) => int): void;
    sublist(start: int, end?: int): core.DartList<Int32x4>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<Int32x4>, skipCount?: int): void;
}
export declare class Float64x2List extends TypedData implements core.DartList<Float64x2> {
    constructor(length: number);
    static _Float64x2List(length: number): Float64x2List;
    static _fromList(elements: core.DartList<Float64x2>): Float64x2List;
    static fromList: new (elements: core.DartList<Float64x2>) => Float64x2List;
    static _view(buffer: ByteBuffer, offsetInBytes?: number, length?: number): Float64x2List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => Float64x2List;
    static BYTES_PER_ELEMENT: number;
    [OperatorMethods.INDEX](index: number): Float64x2;
    [OperatorMethods.INDEX_EQ](index: number, value: Float64x2): void;
    add(element: Float64x2): void;
    addAll(iterable: core.DartIterable<Float64x2>): void;
    any(test: (element: Float64x2) => bool): bool;
    asMap(): core.DartMap<int, Float64x2>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): Float64x2;
    expand<T>(f: (element: Float64x2) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: Float64x2): void;
    readonly first: Float64x2;
    firstWhere(test: (element: Float64x2) => bool, _?: {
        orElse?: () => Float64x2;
    }): Float64x2;
    fold<T>(initialValue: T, combine: (previousValue: T, element: Float64x2) => T): T;
    getRange(start: int, end: int): core.DartIterable<Float64x2>;
    insert(index: int, element: Float64x2): void;
    insertAll(index: int, iterable: core.DartIterable<Float64x2>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<Float64x2>;
    readonly last: Float64x2;
    lastWhere(test: (element: Float64x2) => bool, _?: {
        orElse?: () => Float64x2;
    }): Float64x2;
    map(...args: any[]): any;
    remove(element: Float64x2): bool;
    removeAt(index: int): Float64x2;
    removeLast(): Float64x2;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: Float64x2) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<Float64x2>): void;
    retainWhere(test: (element: Float64x2) => bool): void;
    readonly reversed: core.DartIterable<Float64x2>;
    setAll(index: int, iterable: core.DartIterable<Float64x2>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: Float64x2;
    singleWhere(test: (element: Float64x2) => bool): Float64x2;
    skip(count: int): core.DartIterable<Float64x2>;
    skipWhile(test: (element: Float64x2) => bool): core.DartIterable<Float64x2>;
    take(count: int): core.DartIterable<Float64x2>;
    takeWhile(test: (element: Float64x2) => bool): core.DartIterable<Float64x2>;
    toList(_?: {
        growable: bool;
    }): core.DartList<Float64x2>;
    toSet(): core.DartSet<Float64x2>;
    where(test: (element: Float64x2) => bool): core.DartIterable<Float64x2>;
    [Symbol.iterator](): Iterator<Float64x2>;
    every(f: (element: Float64x2) => boolean): boolean;
    forEach(f: (element: Float64x2) => any): void;
    indexOf(element: Float64x2, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: Float64x2, start?: int): int;
    reduce(combine: (value: Float64x2, element: Float64x2) => Float64x2): Float64x2;
    sort(compare?: (a: Float64x2, b: Float64x2) => int): void;
    sublist(start: int, end?: int): core.DartList<Float64x2>;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<Float64x2>, skipCount?: int): void;
}
export declare class Float32x4 {
    constructor(x: double, y: double, z: double, w: double);
    static _Float32x4(x: double, y: double, z: double, w: double): Float32x4;
    static _splat(v: double): Float32x4;
    static splat: new (v: double) => Float32x4;
    static _zero(): Float32x4;
    static zero: new () => Float32x4;
    static _fromInt32x4Bits(x: Int32x4): Float32x4;
    static fromInt32x4Bits: new (x: Int32x4) => Float32x4;
    static _fromFloat64x2(v: Float64x2): Float32x4;
    static fromFloat64x2: new (v: Float64x2) => Float32x4;
    [OperatorMethods.PLUS](other: Float32x4): Float32x4;
    [OperatorMethods.NEGATE](): Float32x4;
    [OperatorMethods.MINUS](other: Float32x4): Float32x4;
    [OperatorMethods.MULTIPLY](other: Float32x4): Float32x4;
    [OperatorMethods.DIVIDE](other: Float32x4): Float32x4;
    lessThan(other: Float32x4): Int32x4;
    lessThanOrEqual(other: Float32x4): Int32x4;
    greaterThan(other: Float32x4): Int32x4;
    greaterThanOrEqual(other: Float32x4): Int32x4;
    equal(other: Float32x4): Int32x4;
    notEqual(other: Float32x4): Int32x4;
    scale(s: double): Float32x4;
    abs(): Float32x4;
    clamp(lowerLimit: Float32x4, upperLimit: Float32x4): Float32x4;
    readonly x: double;
    readonly y: double;
    readonly z: double;
    readonly w: double;
    readonly signMask: number;
    static XXXX: number;
    static XXXY: number;
    static XXXZ: number;
    static XXXW: number;
    static XXYX: number;
    static XXYY: number;
    static XXYZ: number;
    static XXYW: number;
    static XXZX: number;
    static XXZY: number;
    static XXZZ: number;
    static XXZW: number;
    static XXWX: number;
    static XXWY: number;
    static XXWZ: number;
    static XXWW: number;
    static XYXX: number;
    static XYXY: number;
    static XYXZ: number;
    static XYXW: number;
    static XYYX: number;
    static XYYY: number;
    static XYYZ: number;
    static XYYW: number;
    static XYZX: number;
    static XYZY: number;
    static XYZZ: number;
    static XYZW: number;
    static XYWX: number;
    static XYWY: number;
    static XYWZ: number;
    static XYWW: number;
    static XZXX: number;
    static XZXY: number;
    static XZXZ: number;
    static XZXW: number;
    static XZYX: number;
    static XZYY: number;
    static XZYZ: number;
    static XZYW: number;
    static XZZX: number;
    static XZZY: number;
    static XZZZ: number;
    static XZZW: number;
    static XZWX: number;
    static XZWY: number;
    static XZWZ: number;
    static XZWW: number;
    static XWXX: number;
    static XWXY: number;
    static XWXZ: number;
    static XWXW: number;
    static XWYX: number;
    static XWYY: number;
    static XWYZ: number;
    static XWYW: number;
    static XWZX: number;
    static XWZY: number;
    static XWZZ: number;
    static XWZW: number;
    static XWWX: number;
    static XWWY: number;
    static XWWZ: number;
    static XWWW: number;
    static YXXX: number;
    static YXXY: number;
    static YXXZ: number;
    static YXXW: number;
    static YXYX: number;
    static YXYY: number;
    static YXYZ: number;
    static YXYW: number;
    static YXZX: number;
    static YXZY: number;
    static YXZZ: number;
    static YXZW: number;
    static YXWX: number;
    static YXWY: number;
    static YXWZ: number;
    static YXWW: number;
    static YYXX: number;
    static YYXY: number;
    static YYXZ: number;
    static YYXW: number;
    static YYYX: number;
    static YYYY: number;
    static YYYZ: number;
    static YYYW: number;
    static YYZX: number;
    static YYZY: number;
    static YYZZ: number;
    static YYZW: number;
    static YYWX: number;
    static YYWY: number;
    static YYWZ: number;
    static YYWW: number;
    static YZXX: number;
    static YZXY: number;
    static YZXZ: number;
    static YZXW: number;
    static YZYX: number;
    static YZYY: number;
    static YZYZ: number;
    static YZYW: number;
    static YZZX: number;
    static YZZY: number;
    static YZZZ: number;
    static YZZW: number;
    static YZWX: number;
    static YZWY: number;
    static YZWZ: number;
    static YZWW: number;
    static YWXX: number;
    static YWXY: number;
    static YWXZ: number;
    static YWXW: number;
    static YWYX: number;
    static YWYY: number;
    static YWYZ: number;
    static YWYW: number;
    static YWZX: number;
    static YWZY: number;
    static YWZZ: number;
    static YWZW: number;
    static YWWX: number;
    static YWWY: number;
    static YWWZ: number;
    static YWWW: number;
    static ZXXX: number;
    static ZXXY: number;
    static ZXXZ: number;
    static ZXXW: number;
    static ZXYX: number;
    static ZXYY: number;
    static ZXYZ: number;
    static ZXYW: number;
    static ZXZX: number;
    static ZXZY: number;
    static ZXZZ: number;
    static ZXZW: number;
    static ZXWX: number;
    static ZXWY: number;
    static ZXWZ: number;
    static ZXWW: number;
    static ZYXX: number;
    static ZYXY: number;
    static ZYXZ: number;
    static ZYXW: number;
    static ZYYX: number;
    static ZYYY: number;
    static ZYYZ: number;
    static ZYYW: number;
    static ZYZX: number;
    static ZYZY: number;
    static ZYZZ: number;
    static ZYZW: number;
    static ZYWX: number;
    static ZYWY: number;
    static ZYWZ: number;
    static ZYWW: number;
    static ZZXX: number;
    static ZZXY: number;
    static ZZXZ: number;
    static ZZXW: number;
    static ZZYX: number;
    static ZZYY: number;
    static ZZYZ: number;
    static ZZYW: number;
    static ZZZX: number;
    static ZZZY: number;
    static ZZZZ: number;
    static ZZZW: number;
    static ZZWX: number;
    static ZZWY: number;
    static ZZWZ: number;
    static ZZWW: number;
    static ZWXX: number;
    static ZWXY: number;
    static ZWXZ: number;
    static ZWXW: number;
    static ZWYX: number;
    static ZWYY: number;
    static ZWYZ: number;
    static ZWYW: number;
    static ZWZX: number;
    static ZWZY: number;
    static ZWZZ: number;
    static ZWZW: number;
    static ZWWX: number;
    static ZWWY: number;
    static ZWWZ: number;
    static ZWWW: number;
    static WXXX: number;
    static WXXY: number;
    static WXXZ: number;
    static WXXW: number;
    static WXYX: number;
    static WXYY: number;
    static WXYZ: number;
    static WXYW: number;
    static WXZX: number;
    static WXZY: number;
    static WXZZ: number;
    static WXZW: number;
    static WXWX: number;
    static WXWY: number;
    static WXWZ: number;
    static WXWW: number;
    static WYXX: number;
    static WYXY: number;
    static WYXZ: number;
    static WYXW: number;
    static WYYX: number;
    static WYYY: number;
    static WYYZ: number;
    static WYYW: number;
    static WYZX: number;
    static WYZY: number;
    static WYZZ: number;
    static WYZW: number;
    static WYWX: number;
    static WYWY: number;
    static WYWZ: number;
    static WYWW: number;
    static WZXX: number;
    static WZXY: number;
    static WZXZ: number;
    static WZXW: number;
    static WZYX: number;
    static WZYY: number;
    static WZYZ: number;
    static WZYW: number;
    static WZZX: number;
    static WZZY: number;
    static WZZZ: number;
    static WZZW: number;
    static WZWX: number;
    static WZWY: number;
    static WZWZ: number;
    static WZWW: number;
    static WWXX: number;
    static WWXY: number;
    static WWXZ: number;
    static WWXW: number;
    static WWYX: number;
    static WWYY: number;
    static WWYZ: number;
    static WWYW: number;
    static WWZX: number;
    static WWZY: number;
    static WWZZ: number;
    static WWZW: number;
    static WWWX: number;
    static WWWY: number;
    static WWWZ: number;
    static WWWW: number;
    shuffle(mask: number): Float32x4;
    shuffleMix(other: Float32x4, mask: number): Float32x4;
    withX(x: double): Float32x4;
    withY(y: double): Float32x4;
    withZ(z: double): Float32x4;
    withW(w: double): Float32x4;
    min(other: Float32x4): Float32x4;
    max(other: Float32x4): Float32x4;
    sqrt(): Float32x4;
    reciprocal(): Float32x4;
    reciprocalSqrt(): Float32x4;
}
export declare class Int32x4 {
    constructor(x: number, y: number, z: number, w: number);
    static _Int32x4(x: number, y: number, z: number, w: number): Int32x4;
    static _bool(x: boolean, y: boolean, z: boolean, w: boolean): Int32x4;
    static bool: new (x: boolean, y: boolean, z: boolean, w: boolean) => Int32x4;
    static _fromFloat32x4Bits(x: Float32x4): Int32x4;
    static fromFloat32x4Bits: new (x: Float32x4) => Int32x4;
    [OperatorMethods.BINARY_OR](other: Int32x4): Int32x4;
    [OperatorMethods.BINARY_AND](other: Int32x4): Int32x4;
    [OperatorMethods.XOR](other: Int32x4): Int32x4;
    [OperatorMethods.PLUS](other: Int32x4): Int32x4;
    [OperatorMethods.MINUS](other: Int32x4): Int32x4;
    readonly x: number;
    readonly y: number;
    readonly z: number;
    readonly w: number;
    readonly signMask: number;
    static XXXX: number;
    static XXXY: number;
    static XXXZ: number;
    static XXXW: number;
    static XXYX: number;
    static XXYY: number;
    static XXYZ: number;
    static XXYW: number;
    static XXZX: number;
    static XXZY: number;
    static XXZZ: number;
    static XXZW: number;
    static XXWX: number;
    static XXWY: number;
    static XXWZ: number;
    static XXWW: number;
    static XYXX: number;
    static XYXY: number;
    static XYXZ: number;
    static XYXW: number;
    static XYYX: number;
    static XYYY: number;
    static XYYZ: number;
    static XYYW: number;
    static XYZX: number;
    static XYZY: number;
    static XYZZ: number;
    static XYZW: number;
    static XYWX: number;
    static XYWY: number;
    static XYWZ: number;
    static XYWW: number;
    static XZXX: number;
    static XZXY: number;
    static XZXZ: number;
    static XZXW: number;
    static XZYX: number;
    static XZYY: number;
    static XZYZ: number;
    static XZYW: number;
    static XZZX: number;
    static XZZY: number;
    static XZZZ: number;
    static XZZW: number;
    static XZWX: number;
    static XZWY: number;
    static XZWZ: number;
    static XZWW: number;
    static XWXX: number;
    static XWXY: number;
    static XWXZ: number;
    static XWXW: number;
    static XWYX: number;
    static XWYY: number;
    static XWYZ: number;
    static XWYW: number;
    static XWZX: number;
    static XWZY: number;
    static XWZZ: number;
    static XWZW: number;
    static XWWX: number;
    static XWWY: number;
    static XWWZ: number;
    static XWWW: number;
    static YXXX: number;
    static YXXY: number;
    static YXXZ: number;
    static YXXW: number;
    static YXYX: number;
    static YXYY: number;
    static YXYZ: number;
    static YXYW: number;
    static YXZX: number;
    static YXZY: number;
    static YXZZ: number;
    static YXZW: number;
    static YXWX: number;
    static YXWY: number;
    static YXWZ: number;
    static YXWW: number;
    static YYXX: number;
    static YYXY: number;
    static YYXZ: number;
    static YYXW: number;
    static YYYX: number;
    static YYYY: number;
    static YYYZ: number;
    static YYYW: number;
    static YYZX: number;
    static YYZY: number;
    static YYZZ: number;
    static YYZW: number;
    static YYWX: number;
    static YYWY: number;
    static YYWZ: number;
    static YYWW: number;
    static YZXX: number;
    static YZXY: number;
    static YZXZ: number;
    static YZXW: number;
    static YZYX: number;
    static YZYY: number;
    static YZYZ: number;
    static YZYW: number;
    static YZZX: number;
    static YZZY: number;
    static YZZZ: number;
    static YZZW: number;
    static YZWX: number;
    static YZWY: number;
    static YZWZ: number;
    static YZWW: number;
    static YWXX: number;
    static YWXY: number;
    static YWXZ: number;
    static YWXW: number;
    static YWYX: number;
    static YWYY: number;
    static YWYZ: number;
    static YWYW: number;
    static YWZX: number;
    static YWZY: number;
    static YWZZ: number;
    static YWZW: number;
    static YWWX: number;
    static YWWY: number;
    static YWWZ: number;
    static YWWW: number;
    static ZXXX: number;
    static ZXXY: number;
    static ZXXZ: number;
    static ZXXW: number;
    static ZXYX: number;
    static ZXYY: number;
    static ZXYZ: number;
    static ZXYW: number;
    static ZXZX: number;
    static ZXZY: number;
    static ZXZZ: number;
    static ZXZW: number;
    static ZXWX: number;
    static ZXWY: number;
    static ZXWZ: number;
    static ZXWW: number;
    static ZYXX: number;
    static ZYXY: number;
    static ZYXZ: number;
    static ZYXW: number;
    static ZYYX: number;
    static ZYYY: number;
    static ZYYZ: number;
    static ZYYW: number;
    static ZYZX: number;
    static ZYZY: number;
    static ZYZZ: number;
    static ZYZW: number;
    static ZYWX: number;
    static ZYWY: number;
    static ZYWZ: number;
    static ZYWW: number;
    static ZZXX: number;
    static ZZXY: number;
    static ZZXZ: number;
    static ZZXW: number;
    static ZZYX: number;
    static ZZYY: number;
    static ZZYZ: number;
    static ZZYW: number;
    static ZZZX: number;
    static ZZZY: number;
    static ZZZZ: number;
    static ZZZW: number;
    static ZZWX: number;
    static ZZWY: number;
    static ZZWZ: number;
    static ZZWW: number;
    static ZWXX: number;
    static ZWXY: number;
    static ZWXZ: number;
    static ZWXW: number;
    static ZWYX: number;
    static ZWYY: number;
    static ZWYZ: number;
    static ZWYW: number;
    static ZWZX: number;
    static ZWZY: number;
    static ZWZZ: number;
    static ZWZW: number;
    static ZWWX: number;
    static ZWWY: number;
    static ZWWZ: number;
    static ZWWW: number;
    static WXXX: number;
    static WXXY: number;
    static WXXZ: number;
    static WXXW: number;
    static WXYX: number;
    static WXYY: number;
    static WXYZ: number;
    static WXYW: number;
    static WXZX: number;
    static WXZY: number;
    static WXZZ: number;
    static WXZW: number;
    static WXWX: number;
    static WXWY: number;
    static WXWZ: number;
    static WXWW: number;
    static WYXX: number;
    static WYXY: number;
    static WYXZ: number;
    static WYXW: number;
    static WYYX: number;
    static WYYY: number;
    static WYYZ: number;
    static WYYW: number;
    static WYZX: number;
    static WYZY: number;
    static WYZZ: number;
    static WYZW: number;
    static WYWX: number;
    static WYWY: number;
    static WYWZ: number;
    static WYWW: number;
    static WZXX: number;
    static WZXY: number;
    static WZXZ: number;
    static WZXW: number;
    static WZYX: number;
    static WZYY: number;
    static WZYZ: number;
    static WZYW: number;
    static WZZX: number;
    static WZZY: number;
    static WZZZ: number;
    static WZZW: number;
    static WZWX: number;
    static WZWY: number;
    static WZWZ: number;
    static WZWW: number;
    static WWXX: number;
    static WWXY: number;
    static WWXZ: number;
    static WWXW: number;
    static WWYX: number;
    static WWYY: number;
    static WWYZ: number;
    static WWYW: number;
    static WWZX: number;
    static WWZY: number;
    static WWZZ: number;
    static WWZW: number;
    static WWWX: number;
    static WWWY: number;
    static WWWZ: number;
    static WWWW: number;
    shuffle(mask: number): Int32x4;
    shuffleMix(other: Int32x4, mask: number): Int32x4;
    withX(x: number): Int32x4;
    withY(y: number): Int32x4;
    withZ(z: number): Int32x4;
    withW(w: number): Int32x4;
    readonly flagX: boolean;
    readonly flagY: boolean;
    readonly flagZ: boolean;
    readonly flagW: boolean;
    withFlagX(x: boolean): Int32x4;
    withFlagY(y: boolean): Int32x4;
    withFlagZ(z: boolean): Int32x4;
    withFlagW(w: boolean): Int32x4;
    select(trueValue: Float32x4, falseValue: Float32x4): Float32x4;
}
export declare class Float64x2 {
    constructor(x: double, y: double);
    static _Float64x2(x: double, y: double): Float64x2;
    static _splat(v: double): Float64x2;
    static splat: new (v: double) => Float64x2;
    static _zero(): Float64x2;
    static zero: new () => Float64x2;
    static _fromFloat32x4(v: Float32x4): Float64x2;
    static fromFloat32x4: new (v: Float32x4) => Float64x2;
    [OperatorMethods.PLUS](other: Float64x2): Float64x2;
    [OperatorMethods.NEGATE](): Float64x2;
    [OperatorMethods.MINUS](other: Float64x2): Float64x2;
    [OperatorMethods.MULTIPLY](other: Float64x2): Float64x2;
    [OperatorMethods.DIVIDE](other: Float64x2): Float64x2;
    scale(s: double): Float64x2;
    abs(): Float64x2;
    clamp(lowerLimit: Float64x2, upperLimit: Float64x2): Float64x2;
    readonly x: double;
    readonly y: double;
    readonly signMask: number;
    withX(x: double): Float64x2;
    withY(y: double): Float64x2;
    min(other: Float64x2): Float64x2;
    max(other: Float64x2): Float64x2;
    sqrt(): Float64x2;
}
export declare class NativeByteBufferMixin implements ByteBuffer {
    readonly lengthInBytes: number;
    asUint8List(offsetInBytes?: number, length?: number): Uint8List;
    asInt8List(offsetInBytes?: number, length?: number): Int8List;
    asUint8ClampedList(offsetInBytes?: number, length?: number): Uint8ClampedList;
    asUint16List(offsetInBytes?: number, length?: number): Uint16List;
    asInt16List(offsetInBytes?: number, length?: number): Int16List;
    asUint32List(offsetInBytes?: number, length?: number): Uint32List;
    asInt32List(offsetInBytes?: number, length?: number): Int32List;
    asUint64List(offsetInBytes?: number, length?: number): Uint64List;
    asInt64List(offsetInBytes?: number, length?: number): Int64List;
    asInt32x4List(offsetInBytes?: number, length?: number): Int32x4List;
    asFloat32List(offsetInBytes?: number, length?: number): Float32List;
    asFloat64List(offsetInBytes?: number, length?: number): Float64List;
    asFloat32x4List(offsetInBytes?: number, length?: number): Float32x4List;
    asFloat64x2List(offsetInBytes?: number, length?: number): Float64x2List;
    asByteData(offsetInBytes?: number, length?: number): ByteData;
    readonly byteLength: number;
    slice(begin: number, end?: number): ArrayBuffer;
    readonly [Symbol.toStringTag]: any;
}
export declare class NativeByteBuffer extends ArrayBuffer implements ByteBuffer, NativeByteBufferMixin {
    constructor(len: any);
    readonly lengthInBytes: number;
    asUint8List(offsetInBytes?: number, length?: number): Uint8List;
    asInt8List(offsetInBytes?: number, length?: number): Int8List;
    asUint8ClampedList(offsetInBytes?: number, length?: number): Uint8ClampedList;
    asUint16List(offsetInBytes?: number, length?: number): Uint16List;
    asInt16List(offsetInBytes?: number, length?: number): Int16List;
    asUint32List(offsetInBytes?: number, length?: number): Uint32List;
    asInt32List(offsetInBytes?: number, length?: number): Int32List;
    asUint64List(offsetInBytes?: number, length?: number): Uint64List;
    asInt64List(offsetInBytes?: number, length?: number): Int64List;
    asInt32x4List(offsetInBytes?: number, length?: number): Int32x4List;
    asFloat32List(offsetInBytes?: number, length?: number): Float32List;
    asFloat64List(offsetInBytes?: number, length?: number): Float64List;
    asFloat32x4List(offsetInBytes?: number, length?: number): Float32x4List;
    asFloat64x2List(offsetInBytes?: number, length?: number): Float64x2List;
    asByteData(offsetInBytes?: number, length?: number): ByteData;
    readonly [Symbol.toStringTag]: any;
}
export declare class NativeFloat32x4List extends Float32x4List {
    _storage: NativeFloat32List;
    constructor(length: number);
    NativeFloat32x4List(length: number): void;
    _externalStorage(_storage: NativeFloat32List): void;
    static _externalStorage: new (_storage: NativeFloat32List) => NativeFloat32x4List;
    _slowFromList(list: core.DartList<Float32x4>): void;
    static _slowFromList: new (list: core.DartList<Float32x4>) => NativeFloat32x4List;
    static _fromList(list: core.DartList<Float32x4>): NativeFloat32x4List;
    static fromList: new (list: core.DartList<Float32x4>) => NativeFloat32x4List;
    readonly buffer: ByteBuffer;
    readonly lengthInBytes: number;
    readonly offsetInBytes: number;
    readonly elementSizeInBytes: number;
    readonly length: number;
    [OperatorMethods.INDEX](index: number): Float32x4;
    [OperatorMethods.INDEX_EQ](index: number, value: Float32x4): void;
    sublist(start: number, end?: number): core.DartList<Float32x4>;
}
export declare class NativeInt32x4List extends Int32x4List {
    _storage: Int32List;
    constructor(length: number);
    NativeInt32x4List(length: number): void;
    _externalStorage(storage: Int32List): void;
    static _externalStorage: new (storage: Int32List) => NativeInt32x4List;
    _slowFromList(list: core.DartList<Int32x4>): void;
    static _slowFromList: new (list: core.DartList<Int32x4>) => NativeInt32x4List;
    static _fromList(list: core.DartList<Int32x4>): NativeInt32x4List;
    static fromList: new (list: core.DartList<Int32x4>) => NativeInt32x4List;
    readonly buffer: ByteBuffer;
    readonly lengthInBytes: number;
    readonly offsetInBytes: number;
    readonly elementSizeInBytes: number;
    readonly length: number;
    [OperatorMethods.INDEX](index: number): Int32x4;
    [OperatorMethods.INDEX_EQ](index: number, value: Int32x4): void;
    sublist(start: number, end?: number): core.DartList<Int32x4>;
}
export declare class NativeFloat64x2List extends core.DartListBase<Float64x2> implements Float64x2List {
    _storage: NativeFloat64List;
    constructor(length: number);
    NativeFloat64x2List(length: number): void;
    _externalStorage(_storage: NativeFloat64List): void;
    static _externalStorage: new (_storage: NativeFloat64List) => NativeFloat64x2List;
    _slowFromList(list: core.DartList<Float64x2>): void;
    static _slowFromList: new (list: core.DartList<Float64x2>) => NativeFloat64x2List;
    static _fromList(list: core.DartList<Float64x2>): NativeFloat64x2List;
    static fromList: new (list: core.DartList<Float64x2>) => NativeFloat64x2List;
    readonly buffer: ByteBuffer;
    readonly lengthInBytes: number;
    readonly offsetInBytes: number;
    readonly elementSizeInBytes: number;
    readonly length: number;
    [OperatorMethods.INDEX](index: number): Float64x2;
    [OperatorMethods.INDEX_EQ](index: number, value: Float64x2): void;
    sublist(start: number, end?: number): core.DartList<Float64x2>;
}
export declare class NativeTypedData implements TypedData, ArrayBufferView {
    offsetInBytes: number;
    elementSizeInBytes: number;
    buffer: ByteBuffer;
    readonly lengthInBytes: number;
    _invalidPosition(position: number, length: number, name: string): void;
    _checkPosition(position: number, length: number, name: string): void;
    readonly byteLength: number;
    readonly byteOffset: number;
}
export declare var _checkLength: (length: any) => number;
export declare var _checkViewArguments: (buffer: any, offsetInBytes: any, length: any) => void;
export declare var _ensureNativeList: (list: core.DartList<any>) => core.DartList<any>;
export declare class NativeByteData extends DataView implements ByteData, NativeTypedData {
    constructor(...args: any[]);
    static _view(buffer: ByteBuffer, offsetInBytes: number, length: number): NativeByteData;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => NativeByteData;
    readonly elementSizeInBytes: number;
    getFloat32(byteOffset: number, endian?: Endianness | boolean): number;
    getFloat64(byteOffset: number, endian?: Endianness | boolean): number;
    getInt16(byteOffset: number, endian?: Endianness | boolean): number;
    getInt32(byteOffset: number, endian?: Endianness | boolean): number;
    getInt64(byteOffset: number, endian?: Endianness): number;
    getUint16(byteOffset: number, endian?: Endianness | boolean): number;
    getUint32(byteOffset: number, endian?: Endianness | boolean): number;
    getUint64(byteOffset: number, endian?: Endianness): number;
    setFloat32(byteOffset: number, value: number, endian?: Endianness | boolean): void;
    setFloat64(byteOffset: number, value: number, endian?: Endianness | boolean): void;
    setInt16(byteOffset: number, value: number, endian?: Endianness | boolean): void;
    setInt32(byteOffset: number, value: number, endian?: Endianness | boolean): void;
    setInt64(byteOffset: number, value: number, endian?: Endianness | boolean): void;
    setUint16(byteOffset: number, value: number, endian?: Endianness | boolean): void;
    setUint32(byteOffset: number, value: number, endian?: Endianness | boolean): void;
    setUint64(byteOffset: number, value: number, endian?: Endianness | boolean): void;
    static _create1(arg: any): NativeByteData;
    static _create2(arg1: any, arg2: any): NativeByteData;
    static _create3(arg1: any, arg2: any, arg3: any): NativeByteData;
    _checkPosition(position: number, length: number, name: string): void;
    _invalidPosition(position: number, length: number, name: string): void;
    readonly buffer: ByteBuffer;
    readonly lengthInBytes: number;
    readonly offsetInBytes: number;
}
export declare class NativeTypedArray extends NativeTypedData {
    readonly length: number;
    _setRangeFast(start: number, end: number, source: NativeTypedArray, skipCount: number): void;
}
export declare class NativeTypedArrayOfDouble extends NativeTypedArray implements core.DartList<number> {
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    setRange(start: number, end: number, iterable: core.DartIterable<double>, skipCount?: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    readonly elementSizeInBytes: number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
}
export declare class NativeTypedArrayOfInt extends NativeTypedArray implements core.DartList<number> {
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    setRange(start: number, end: number, iterable: core.DartIterable<number>, skipCount?: number): void;
    [OperatorMethods.INDEX](index: number): number;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    readonly elementSizeInBytes: number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): Iterator<number>;
    every(f: (element: number) => boolean): boolean;
    forEach(f: (element: number) => any): void;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(combine: (value: number, element: number) => number): number;
    sort(compare?: (a: number, b: number) => int): void;
    sublist(start: int, end?: int): core.DartList<number>;
}
export declare class NativeFloat32List extends Float32Array implements NativeTypedArrayOfDouble, Float32List {
    protected constructor(length: number | ArrayBufferLike | ArrayLike<number> | core.DartList<number>);
    protected constructor(buffer: ByteBuffer, byteOffset: number, length?: number);
    static _withLength(len: number): NativeFloat32List;
    static withLength: new (len: number) => NativeFloat32List;
    static _fromList(elements: core.DartList<double>): NativeFloat32List;
    static fromList: new (elements: core.DartList<double>) => NativeFloat32List;
    static _view(buffer: ByteBuffer, offsetInBytes: number, length: number): NativeFloat32List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => NativeFloat32List;
    sublist(start: number, end?: number): core.DartList<double>;
    static _create1(lenOrSource: number | ArrayBufferLike | ArrayLike<number> | core.DartList<number>): NativeFloat32List;
    static _create2(arg1: any, arg2: any): NativeFloat32List;
    static _create3(arg1: any, arg2: any, arg3: any): NativeFloat32List;
    buffer: any;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    every(...args: any[]): any;
    forEach(...args: any[]): any;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(...args: any[]): any;
    sort(...args: any[]): any;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
    _checkPosition(position: number, length: number, name: string): void;
    _invalidPosition(position: number, length: number, name: string): void;
    _setRangeFast(start: number, end: number, source: NativeTypedArray, skipCount: number): void;
    readonly elementSizeInBytes: number;
    readonly lengthInBytes: number;
    readonly offsetInBytes: number;
}
export declare class NativeFloat64List extends Float64Array implements NativeTypedArrayOfDouble, Float64List {
    protected constructor(length: number | ArrayBufferLike | ArrayLike<number> | core.DartList<number>);
    protected constructor(buffer: ByteBuffer, byteOffset: number, length?: number);
    static _withLength(len: number): NativeFloat64List;
    static withLength: new (len: number) => NativeFloat64List;
    static _fromList(elements: core.DartList<double>): NativeFloat64List;
    static fromList: new (elements: core.DartList<double>) => NativeFloat64List;
    static _view(buffer: ByteBuffer, offsetInBytes: number, length: number): NativeFloat64List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => NativeFloat64List;
    sublist(start: number, end?: number): core.DartList<double>;
    static _create1(lenOrSource: number | ArrayBufferLike | ArrayLike<number> | core.DartList<number>): NativeFloat64List;
    static _create2(arg1: any, arg2: any): NativeFloat64List;
    static _create3(arg1: any, arg2: any, arg3: any): NativeFloat64List;
    buffer: any;
    [OperatorMethods.INDEX](index: number): number;
    [OperatorMethods.INDEX_EQ](index: number, value: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    every(...args: any[]): any;
    forEach(...args: any[]): any;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(...args: any[]): any;
    sort(...args: any[]): any;
    readonly length: int;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
    _checkPosition(position: number, length: number, name: string): void;
    _invalidPosition(position: number, length: number, name: string): void;
    _setRangeFast(start: number, end: number, source: NativeTypedArray, skipCount: number): void;
    readonly elementSizeInBytes: number;
    readonly lengthInBytes: number;
    readonly offsetInBytes: number;
}
export declare class NativeInt16List extends Int16Array implements NativeTypedArrayOfInt, Int16List {
    constructor(...args: any[]);
    static _fromList(elements: core.DartList<number>): NativeInt16List;
    static fromList: new (elements: core.DartList<number>) => NativeInt16List;
    static _view(buffer: NativeByteBuffer, offsetInBytes: number, length: number): NativeInt16List;
    static view: new (buffer: NativeByteBuffer, offsetInBytes: number, length: number) => NativeInt16List;
    [OperatorMethods.INDEX](index: number): number;
    sublist(start: number, end?: number): core.DartList<number>;
    static _create1(arg: any): NativeInt16List;
    static _create2(arg1: any, arg2: any): NativeInt16List;
    static _create3(arg1: any, arg2: any, arg3: any): NativeInt16List;
    [OperatorMethods.INDEX_EQ](index: number, val: number): void;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    readonly elementSizeInBytes: number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    map(...args: any[]): any;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    [Symbol.iterator](): IterableIterator<number>;
    every(...args: any[]): any;
    forEach(...args: any[]): any;
    indexOf(element: number, start?: int): int;
    join(separator?: string): string;
    lastIndexOf(element: number, start?: int): int;
    reduce(...args: any[]): any;
    sort(...args: any[]): any;
    _checkPosition(position: number, length: number, name: string): void;
    _invalidPosition(position: number, length: number, name: string): void;
    _setRangeFast(start: number, end: number, source: NativeTypedArray, skipCount: number): void;
    readonly buffer: ByteBuffer;
    readonly lengthInBytes: number;
    readonly offsetInBytes: number;
    setRange(start: number | int, end: number | int, iterable: core.DartIterable<number>, skipCount?: number | int): void;
}
export declare class NativeInt32List extends Int32Array implements Int32List, NativeTypedArrayOfInt {
    constructor(...args: any[]);
    static _fromList(elements: core.DartList<number>): NativeInt32List;
    static fromList: new (elements: core.DartList<number>) => NativeInt32List;
    static _view(buffer: ByteBuffer, offsetInBytes: number, length: number): NativeInt32List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => NativeInt32List;
    [OperatorMethods.INDEX](index: number): number;
    sublist(start: number, end?: number): core.DartList<number>;
    static _create1(arg: any): NativeInt32List;
    static _create2(arg1: any, arg2: any): NativeInt32List;
    static _create3(arg1: any, arg2: any, arg3: any): NativeInt32List;
    [OperatorMethods.INDEX_EQ](number: int, value: int): void;
    readonly buffer: ByteBuffer;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    readonly elementSizeInBytes: number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    readonly lengthInBytes: number;
    map(...args: any[]): any;
    readonly offsetInBytes: number;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    _checkPosition(position: number, length: number, name: string): void;
    _invalidPosition(position: number, length: number, name: string): void;
    _setRangeFast(start: number, end: number, source: NativeTypedArray, skipCount: number): void;
}
export declare class NativeInt8List extends Int8Array implements Int8List, NativeTypedArrayOfInt {
    constructor(...args: any[]);
    static _fromList(elements: core.DartList<number>): NativeInt8List;
    static fromList: new (elements: core.DartList<number>) => NativeInt8List;
    static _view(buffer: ByteBuffer, offsetInBytes: number, length: number): NativeInt8List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => NativeInt8List;
    [OperatorMethods.INDEX](index: number): number;
    sublist(start: number, end?: number): core.DartList<number>;
    static _create1(arg: any): NativeInt8List;
    static _create2(arg1: any, arg2: any): NativeInt8List;
    static _create3(arg1: any, arg2: any, arg3: any): NativeInt8List;
    [OperatorMethods.INDEX_EQ](number: int, value: int): void;
    readonly buffer: ByteBuffer;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    readonly elementSizeInBytes: number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    readonly lengthInBytes: number;
    map(...args: any[]): any;
    readonly offsetInBytes: number;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    _checkPosition(position: number, length: number, name: string): void;
    _invalidPosition(position: number, length: number, name: string): void;
    _setRangeFast(start: number, end: number, source: NativeTypedArray, skipCount: number): void;
}
export declare class NativeUint16List extends Uint16Array implements Uint16List, NativeTypedArrayOfInt {
    protected constructor(length: number | ArrayBufferLike | ArrayLike<number> | core.DartList<number>);
    protected constructor(buffer: ByteBuffer, byteOffset: number, length?: number);
    static _withLength(len: number): NativeUint16List;
    static withLength: new (len: number) => Uint16List;
    static _fromList(list: core.DartList<number>): NativeUint16List;
    static fromList: new (list: core.DartList<number>) => NativeUint16List;
    static _view(buffer: ByteBuffer, offsetInBytes: number, length: number): NativeUint16List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => NativeUint16List;
    [OperatorMethods.INDEX](index: number): number;
    sublist(start: number, end?: number): core.DartList<number>;
    static _create1(lenOrSource: number | ArrayBufferLike | ArrayLike<number> | core.DartList<number>): NativeUint16List;
    static _create2(arg1: any, arg2: any): NativeUint16List;
    static _create3(arg1: any, arg2: any, arg3: any): NativeUint16List;
    [OperatorMethods.INDEX_EQ](number: int, value: int): void;
    readonly buffer: ByteBuffer;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    readonly elementSizeInBytes: number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    readonly lengthInBytes: number;
    map(...args: any[]): any;
    readonly offsetInBytes: number;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    _checkPosition(position: number, length: number, name: string): void;
    _invalidPosition(position: number, length: number, name: string): void;
    _setRangeFast(start: number, end: number, source: NativeTypedArray, skipCount: number): void;
}
export declare class NativeUint32List extends Uint32Array implements Uint32List, NativeTypedArrayOfInt {
    constructor(...args: any[]);
    static _fromList(elements: core.DartList<number>): NativeUint32List;
    static fromList: new (elements: core.DartList<number>) => NativeUint32List;
    static _view(buffer: ByteBuffer, offsetInBytes: number, length: number): NativeUint32List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => NativeUint32List;
    [OperatorMethods.INDEX](index: number): number;
    sublist(start: number, end?: number): core.DartList<number>;
    static _create1(arg: any): NativeUint32List;
    static _create2(arg1: any, arg2: any): NativeUint32List;
    static _create3(arg1: any, arg2: any, arg3: any): NativeUint32List;
    [OperatorMethods.INDEX_EQ](number: int, value: int): void;
    readonly buffer: ByteBuffer;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    readonly elementSizeInBytes: number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    readonly lengthInBytes: number;
    map(...args: any[]): any;
    readonly offsetInBytes: number;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    _checkPosition(position: number, length: number, name: string): void;
    _invalidPosition(position: number, length: number, name: string): void;
    _setRangeFast(start: number, end: number, source: NativeTypedArray, skipCount: number): void;
}
export declare class NativeUint8ClampedList extends Uint8ClampedArray implements Uint8ClampedList, NativeTypedArrayOfInt {
    constructor(...args: any[]);
    static _fromList(elements: core.DartList<number>): NativeUint8ClampedList;
    static fromList: new (elements: core.DartList<number>) => NativeUint8ClampedList;
    static _view(buffer: ByteBuffer, offsetInBytes: number, length: number): NativeUint8ClampedList;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => NativeUint8ClampedList;
    readonly length: number;
    [OperatorMethods.INDEX](index: number): number;
    sublist(start: number, end?: number): core.DartList<number>;
    static _create1(arg: any): NativeUint8ClampedList;
    static _create2(arg1: any, arg2: any): NativeUint8ClampedList;
    static _create3(arg1: any, arg2: any, arg3: any): NativeUint8ClampedList;
    [OperatorMethods.INDEX_EQ](number: int, value: int): void;
    readonly buffer: ByteBuffer;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    readonly elementSizeInBytes: number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    readonly lengthInBytes: number;
    map(...args: any[]): any;
    readonly offsetInBytes: number;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    _checkPosition(position: number, length: number, name: string): void;
    _invalidPosition(position: number, length: number, name: string): void;
    _setRangeFast(start: number, end: number, source: NativeTypedArray, skipCount: number): void;
}
export declare class NativeUint8List extends Uint8Array implements Uint8List, NativeTypedArrayOfInt {
    constructor(...args: any[]);
    static _fromList(elements: core.DartList<number>): NativeUint8List;
    static fromList: new (elements: core.DartList<number>) => NativeUint8List;
    static _view(buffer: ByteBuffer, offsetInBytes: number, length: number): NativeUint8List;
    static view: new (buffer: ByteBuffer, offsetInBytes: number, length: number) => NativeUint8List;
    [OperatorMethods.INDEX](index: number): number;
    sublist(start: number, end?: number): core.DartList<number>;
    static _create1(arg: any): NativeUint8List;
    static _create2(arg1: any, arg2: any): NativeUint8List;
    static _create3(arg1: any, arg2: any, arg3: any): NativeUint8List;
    [OperatorMethods.INDEX_EQ](number: int, value: int): void;
    readonly buffer: ByteBuffer;
    add(element: number): void;
    addAll(iterable: core.DartIterable<number>): void;
    any(test: (element: number) => bool): bool;
    asMap(): core.DartMap<int, number>;
    clear(): void;
    contains(element: any): bool;
    elementAt(index: int): number;
    readonly elementSizeInBytes: number;
    expand<T>(f: (element: number) => core.DartIterable<T>): core.DartIterable<T>;
    fillRange(start: int, end: int, fill?: number): void;
    readonly first: number;
    firstWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    fold<T>(initialValue: T, combine: (previousValue: T, element: number) => T): T;
    getRange(start: int, end: int): core.DartIterable<number>;
    insert(index: int, element: number): void;
    insertAll(index: int, iterable: core.DartIterable<number>): void;
    readonly isEmpty: boolean;
    readonly isNotEmpty: bool;
    readonly iterator: core.DartIterator<number>;
    readonly last: number;
    lastWhere(test: (element: number) => bool, _?: {
        orElse?: () => number;
    }): number;
    readonly lengthInBytes: number;
    map(...args: any[]): any;
    readonly offsetInBytes: number;
    remove(element: any): bool;
    removeAt(index: int): number;
    removeLast(): number;
    removeRange(start: int, end: int): void;
    removeWhere(test: (element: number) => bool): void;
    replaceRange(start: int, end: int, newContents: core.DartIterable<number>): void;
    retainWhere(test: (element: number) => bool): void;
    readonly reversed: core.DartIterable<number>;
    setAll(index: int, iterable: core.DartIterable<number>): void;
    setRange(start: int, end: int, iterable: core.DartIterable<number>, skipCount?: int): void;
    shuffle(random?: core.DartRandom): void;
    readonly single: number;
    singleWhere(test: (element: number) => bool): number;
    skip(count: int): core.DartIterable<number>;
    skipWhile(test: (element: number) => bool): core.DartIterable<number>;
    take(count: int): core.DartIterable<number>;
    takeWhile(test: (element: number) => bool): core.DartIterable<number>;
    toList(_?: {
        growable: bool;
    }): core.DartList<number>;
    toSet(): core.DartSet<number>;
    where(test: (element: number) => bool): core.DartIterable<number>;
    _checkPosition(position: number, length: number, name: string): void;
    _invalidPosition(position: number, length: number, name: string): void;
    _setRangeFast(start: number, end: number, source: NativeTypedArray, skipCount: number): void;
}
export declare class NativeFloat32x4 implements Float32x4 {
    x: double;
    y: double;
    z: double;
    w: double;
    static _list: NativeFloat32List;
    static _uint32view: Uint32List;
    static _truncate(x: any): any;
    constructor(x: double, y: double, z: double, w: double);
    NativeFloat32x4(x: double, y: double, z: double, w: double): void;
    splat(v: double): void;
    static splat: new (v: double) => NativeFloat32x4;
    zero(): void;
    static zero: new () => NativeFloat32x4;
    static _fromInt32x4Bits(i: Int32x4): NativeFloat32x4;
    static fromInt32x4Bits: new (i: Int32x4) => NativeFloat32x4;
    fromFloat64x2(v: Float64x2): void;
    static fromFloat64x2: new (v: Float64x2) => NativeFloat32x4;
    _doubles(x: double, y: double, z: double, w: double): void;
    static _doubles: new (x: double, y: double, z: double, w: double) => NativeFloat32x4;
    _truncated(x: double, y: double, z: double, w: double): void;
    static _truncated: new (x: double, y: double, z: double, w: double) => NativeFloat32x4;
    toString(): string;
    [OperatorMethods.PLUS](other: Float32x4): Float32x4;
    [OperatorMethods.NEGATE](): Float32x4;
    [OperatorMethods.MINUS](other: Float32x4): Float32x4;
    [OperatorMethods.MULTIPLY](other: Float32x4): Float32x4;
    [OperatorMethods.DIVIDE](other: Float32x4): Float32x4;
    lessThan(other: Float32x4): Int32x4;
    lessThanOrEqual(other: Float32x4): Int32x4;
    greaterThan(other: Float32x4): Int32x4;
    greaterThanOrEqual(other: Float32x4): Int32x4;
    equal(other: Float32x4): Int32x4;
    notEqual(other: Float32x4): Int32x4;
    scale(s: double): Float32x4;
    abs(): Float32x4;
    clamp(lowerLimit: Float32x4, upperLimit: Float32x4): Float32x4;
    readonly signMask: number;
    shuffle(mask: number): Float32x4;
    shuffleMix(other: Float32x4, mask: number): Float32x4;
    withX(newX: double): Float32x4;
    withY(newY: double): Float32x4;
    withZ(newZ: double): Float32x4;
    withW(newW: double): Float32x4;
    min(other: Float32x4): Float32x4;
    max(other: Float32x4): Float32x4;
    sqrt(): Float32x4;
    reciprocal(): Float32x4;
    reciprocalSqrt(): Float32x4;
}
export declare class NativeInt32x4 implements Int32x4 {
    x: number;
    y: number;
    z: number;
    w: number;
    static _list: NativeInt32List;
    static _truncate(x: any): any;
    constructor(x: number, y: number, z: number, w: number);
    NativeInt32x4(x: number, y: number, z: number, w: number): void;
    bool(x: boolean, y: boolean, z: boolean, w: boolean): void;
    static bool: new (x: boolean, y: boolean, z: boolean, w: boolean) => NativeInt32x4;
    static _fromFloat32x4Bits(f: Float32x4): NativeInt32x4;
    static fromFloat32x4Bits: new (f: Float32x4) => NativeInt32x4;
    _truncated(x: number, y: number, z: number, w: number): void;
    static _truncated: new (x: number, y: number, z: number, w: number) => NativeInt32x4;
    toString(): string;
    [OperatorMethods.BINARY_OR](other: Int32x4): Int32x4;
    [OperatorMethods.BINARY_AND](other: Int32x4): Int32x4;
    [OperatorMethods.XOR](other: Int32x4): Int32x4;
    [OperatorMethods.PLUS](other: Int32x4): Int32x4;
    [OperatorMethods.MINUS](other: Int32x4): Int32x4;
    [OperatorMethods.NEGATE](): Int32x4;
    readonly signMask: number;
    shuffle(mask: number): Int32x4;
    shuffleMix(other: Int32x4, mask: number): Int32x4;
    withX(x: number): Int32x4;
    withY(y: number): Int32x4;
    withZ(z: number): Int32x4;
    withW(w: number): Int32x4;
    readonly flagX: boolean;
    readonly flagY: boolean;
    readonly flagZ: boolean;
    readonly flagW: boolean;
    withFlagX(flagX: boolean): Int32x4;
    withFlagY(flagY: boolean): Int32x4;
    withFlagZ(flagZ: boolean): Int32x4;
    withFlagW(flagW: boolean): Int32x4;
    select(trueValue: Float32x4, falseValue: Float32x4): Float32x4;
}
export declare class NativeFloat64x2 implements Float64x2 {
    x: double;
    y: double;
    static _list: NativeFloat64List;
    static _uint32View: NativeUint32List;
    constructor(x: double, y: double);
    NativeFloat64x2(x: double, y: double): void;
    splat(v: double): void;
    static splat: new (v: double) => NativeFloat64x2;
    zero(): void;
    static zero: new () => NativeFloat64x2;
    fromFloat32x4(v: Float32x4): void;
    static fromFloat32x4: new (v: Float32x4) => NativeFloat64x2;
    _doubles(x: double, y: double): void;
    static _doubles: new (x: double, y: double) => NativeFloat64x2;
    toString(): string;
    [OperatorMethods.PLUS](other: Float64x2): Float64x2;
    [OperatorMethods.NEGATE](): Float64x2;
    [OperatorMethods.MINUS](other: Float64x2): Float64x2;
    [OperatorMethods.MULTIPLY](other: Float64x2): Float64x2;
    [OperatorMethods.DIVIDE](other: Float64x2): Float64x2;
    scale(s: double): Float64x2;
    abs(): Float64x2;
    clamp(lowerLimit: Float64x2, upperLimit: Float64x2): Float64x2;
    readonly signMask: number;
    withX(x: double): Float64x2;
    withY(y: double): Float64x2;
    min(other: Float64x2): Float64x2;
    max(other: Float64x2): Float64x2;
    sqrt(): Float64x2;
}
export declare var _isInvalidArrayIndex: (index: number) => boolean;
export declare var _checkValidIndex: (index: number, list: core.DartList<any>, length: number) => void;
export declare var _checkValidRange: (start: number, end: number, length: number) => number;
export declare class Endianness {
    _(_littleEndian: boolean): void;
    static _: new (_littleEndian: boolean) => Endianness;
    static BIG_ENDIAN: Endianness;
    static LITTLE_ENDIAN: Endianness;
    static HOST_ENDIAN: Endianness;
    _littleEndian: boolean;
}
export declare class _Properties {
}
export declare const properties: _Properties;
